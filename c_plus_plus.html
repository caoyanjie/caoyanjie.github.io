---
layout: default
menu_index: 3
---

<div class="box">
  <div class="code">
    <p>【C++11多线程】</p>
    <p>标签： std::thread std::mutex std::atomic std::conditional_varible</p>
    <p>我们对比单线程和多线程的时间性能：</p>
    <p>我们用 Sleep(5000) 函数让程序休眠 5 秒用来模拟函数执行了一系列耗时的操作</p>
    {% highlight c++ %}
  #include <iostream>
  #include <thread>
  #include <time.h>
  #include <Windows.h>

  void func1()
  {
      std::cout << "\n开始执行 func1()......" << std::endl;
      Sleep(5000);
      std::cout << "func1() 执行完毕！" << std::endl;
  }

  void func2()
  {
      std::cout << "\n开始执行 func2()......" << std::endl;
      Sleep(5000);
      std::cout << "func2() 执行完毕！" << std::endl;
  }
    {% endhighlight %}
    <p>
    	接下来我们分别用 单线程 和 多线程 来调用这两个函数，对比执行的时间：
	</p>
    <p>1.单线程串行执行</p>
    {% highlight c++ %}
  int main(void)
  {
      // 开始计时
      time_t _start, _end;
      _start = clock();

      // 单线程串行执行
      func1();
      func2();

      // 结束计时，查看结果
      _end = clock();
      std::cout << "\n用时 " << (_end - _start) / 1000 << "秒" << std::endl << std::endl;

      system("pause");
      return;
  }
    {% endhighlight %}

    <p>2.多线程并行执行</p>
    {% highlight c++ %}
  int main(void)
  {
      // 开始计时
      time_t _start, _end;
      _start = clock();

      // 多线程并行执行
      std::thread _subThread1(func1);
      std::thread _subThread2(func2);
      _subThread1.detach();
      _subThread2.join();

      // 结束计时，查看结果
      _end = clock();
      std::cout << "\n用时 " << (_end - _start) / 1000 << "秒" << std::endl << std::endl;

      system("pause");
      return;
  }
    {% endhighlight %}

    <p>
    	可以看到用单线程执行 func1() 和 func2() 共耗时 10 秒，是 func1() 和 func2() 单独执行的时间总和，而用多线程执行万2个函数总共耗时 5 秒，因为他们是并行同时执行的，并不是 func1() 执行完才执行 func2() 而是 func1() 和 func2() 同时执行的
    </p>

    <br />
    <hr>
    <br />

    <p>
    	上面我们假设 func1() 和 func2() 是毫无关系的两个独立逻辑的函数，如果我们的两个函数要进行共享数据，就不能像单线程一样随意对共有变量进行赋值，因为2个线程同时对一块内存进行写入程序就会崩溃，此时就要用到锁：std::mutex
    </p>
    {% highlight c++ %}
  #include <iostream>
  #include <thread>
  #include <queue>
  #include <mutex>

  std::queue<unsigned long long> s_shareData;    // 共享队列
  std::mutex s_lock;                            // 全局锁

  // 生产者
  void makeData()
  {
      unsigned long long _value = 0;
      while (true)
      {
          s_lock.lock();				// 加锁
          s_shareData.push(_value);		// 存数据
          s_lock.unlock();				// 解锁
          _value++;
      }
  }

  // 消费者
  void useData()
  {
      while (true)
      {
          s_lock.lock();                                         // 加锁
          if (!s_shareData.empty())
          {
              unsigned long long _value = s_shareData.front();    // 取数据
              s_shareData.pop();
              s_lock.unlock();                                   // 解锁
              std::cout << "data: " << _value << std::endl;
              continue;
          }
          s_lock.unlock();
      }
  }

  // 使用
  int main(void)
  {
      // 生产者线程
      std::thread s1(makeData);
      s1.detach();

      // 消费者线程(主线程)
      useData();

      return 0;
  }
    {% endhighlight %}
  </div>
    }
</div>